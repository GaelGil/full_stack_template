### Docker

### to make start up docker container after changes to dockerfile or yml

```
docker compose up --build
```

### to stop the docker container

```
docker compose down -v
```

### to access the psql server running in the container

```
docker exec -it projectname-db-1 psql -U postgres -d dbname
```

### What is dokcer-compose.yml

contains instructions for docker on how to create the container

# Backend

## If we are changing models (updating creating deleting etc)

### Step 1

Apply changes to model.py or

### Step 2 (commit changes/generate migration)

```
docker compose exec backend flask db migrate -m "your message"
```

or

```
docker exec -it projectname-backend-1 /bin/sh
flask db migrate -m "your message"

```

After generating the migration edit migration manually if needed (column/table name change)

### Step 3 (update the database)

Apply migration to database

```
docker compose exec backend flask db upgrade
```

or

```
docker compose exec backend sh # (docker exec -it projectname-backend-1 /bin/sh)
flask db upgrade
```

# to sign into backend container

```

docker compose exec backend sh # (docker exec -it projectname-backend-1 /bin/sh)
```

# to sign into frontend container

```
docker compose exec frontend sh # (docker exec -it projectname-frontend-1 /bin/sh)
```

# When to manually update alembic migrations

- Alembic misses something (e.g., it doesn't detect dropped/renamed tables or relationships)

- You're renaming a table or column (Alembic treats it as a drop + create)

- You need data migration, not just schema (e.g., copying data from friends to followers)

- You need custom constraints (e.g., check constraints, index naming, etc.)
- When changing the name of a table or column in a model/table
- We must update the migration manually or else we risk losing the data

## Example

We change this table from user to users

```
class User(db.Model):
**tablename** = 'users' # we changed the name from user -> users

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
```

### We then run

```
flask db migrate -m "Rename user table"
```

Alembic will output something like this in the migration:

```
def upgrade():
op.create_table('users', ...) # new table
op.drop_table('user') # drops old one
```

this is deleting the database and creating a new one, meaning we lose the data. instead we want to properly Rename

### first we do

class User(db.Model):
**tablename** = 'users'

# note: change any refrence of the old table 'user' to 'users'

# then we generate the migration

docker compose exec backend flask db migrate -m "Rename table from user to users"

# the migration file generated was (a7163da23160_rename_table_from_user_to_users.py)

```
"""Rename table from user to users

Revision ID: a7163da23160
Revises: fc863d9b21a9
Create Date: 2025-07-03 03:55:24.055534

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.

revision = 'a7163da23160'
down_revision = 'fc863d9b21a9'
branch_labels = None
depends_on = None

def upgrade(): # ### commands auto generated by Alembic - please adjust! ###
op.create*table('users',
sa.Column('id', sa.Integer(), nullable=False),
sa.Column('username', sa.String(length=80), nullable=False),
sa.Column('email', sa.String(length=80), nullable=False),
sa.Column('password', sa.String(length=80), nullable=False),
sa.PrimaryKeyConstraint('id'),
sa.UniqueConstraint('email'),
sa.UniqueConstraint('username')
)
op.drop_table('user')
with op.batch_alter_table('friends', schema=None) as batch_op:
batch_op.drop_constraint(batch_op.f('friends_user_id_fkey'), type*='foreignkey')
batch*op.drop_constraint(batch_op.f('friends_friend_id_fkey'), type*='foreignkey')
batch_op.create_foreign_key(None, 'users', ['user_id'], ['id'])
batch_op.create_foreign_key(None, 'users', ['friend_id'], ['id'])

    with op.batch_alter_table('post', schema=None) as batch_op:
        batch_op.drop_constraint(batch_op.f('post_user_id_fkey'), type_='foreignkey')
        batch_op.create_foreign_key(None, 'users', ['user_id'], ['id'])

    # ### end Alembic commands ###

def downgrade(): # ### commands auto generated by Alembic - please adjust! ###
with op.batch*alter_table('post', schema=None) as batch_op:
batch_op.drop_constraint(None, type*='foreignkey')
batch_op.create_foreign_key(batch_op.f('post_user_id_fkey'), 'user', ['user_id'], ['id'])

    with op.batch_alter_table('friends', schema=None) as batch_op:
        batch_op.drop_constraint(None, type_='foreignkey')
        batch_op.drop_constraint(None, type_='foreignkey')
        batch_op.create_foreign_key(batch_op.f('friends_friend_id_fkey'), 'user', ['friend_id'], ['id'])
        batch_op.create_foreign_key(batch_op.f('friends_user_id_fkey'), 'user', ['user_id'], ['id'])

    op.create_table('user',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('username', sa.VARCHAR(length=80), autoincrement=False, nullable=False),
    sa.Column('email', sa.VARCHAR(length=80), autoincrement=False, nullable=False),
    sa.Column('password', sa.VARCHAR(length=80), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('user_pkey')),
    sa.UniqueConstraint('email', name=op.f('user_email_key'), postgresql_include=[], postgresql_nulls_not_distinct=False),
    sa.UniqueConstraint('username', name=op.f('user_username_key'), postgresql_include=[], postgresql_nulls_not_distinct=False)
    )
    op.drop_table('users')
    # ### end Alembic commands ###
```

# now we manually update it to

```
"""Rename table from user to users

Revision ID: a7163da23160
Revises: fc863d9b21a9
Create Date: 2025-07-03 03:55:24.055534

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.

revision = 'a7163da23160'
down_revision = 'fc863d9b21a9'
branch_labels = None
depends_on = None

def upgrade():
op.rename_table('user', 'users') #### this part

    with op.batch_alter_table('friends', schema=None) as batch_op:
        batch_op.drop_constraint(batch_op.f('friends_user_id_fkey'), type_='foreignkey')
        batch_op.drop_constraint(batch_op.f('friends_friend_id_fkey'), type_='foreignkey')
        batch_op.create_foreign_key(None, 'users', ['user_id'], ['id'])
        batch_op.create_foreign_key(None, 'users', ['friend_id'], ['id'])

    with op.batch_alter_table('post', schema=None) as batch_op:
        batch_op.drop_constraint(batch_op.f('post_user_id_fkey'), type_='foreignkey')
        batch_op.create_foreign_key(None, 'users', ['user_id'], ['id'])

def downgrade():
with op.batch*alter_table('post', schema=None) as batch_op:
batch_op.drop_constraint(None, type*='foreignkey')
batch_op.create_foreign_key(batch_op.f('post_user_id_fkey'), 'user', ['user_id'], ['id'])

    with op.batch_alter_table('friends', schema=None) as batch_op:
        batch_op.drop_constraint(None, type_='foreignkey')
        batch_op.drop_constraint(None, type_='foreignkey')
        batch_op.create_foreign_key(batch_op.f('friends_friend_id_fkey'), 'user', ['friend_id'], ['id'])
        batch_op.create_foreign_key(batch_op.f('friends_user_id_fkey'), 'user', ['user_id'], ['id'])

    op.rename_table('users', 'user') #### and this part
```

# verify change

docker exec -it full_stack_template-db-1 psql -U postgres -d projectdb
\dt
SELECT \* FROM users;

# similarly for altering col names

def upgrade():
op.add_column('users', sa.Column('user_name', sa.String(length=80), nullable=False))
op.execute('UPDATE users SET user_name = username')
op.drop_column('users', 'username')

def downgrade():
op.add_column('users', sa.Column('username', sa.String(length=80), nullable=False))
op.execute('UPDATE users SET username = user_name')
op.drop_column('users', 'user_name')

# change to this

def upgrade():
op.alter_column('users', 'username', new_column_name='user_name')

def downgrade():
op.alter_column('users', 'user_name', new_column_name='username')

# will keep tables

docker compose down Removes containers and networks, volumes kept

# will not keep tables

docker compose down -v Removes containers, networks, and volumes deleted

```

```
